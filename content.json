{"meta":{"title":"G&T","subtitle":"技术其实只是解决问题的工具,是抽象的锤头、锯子,并没什么了不起,而真正振奋人心的是用技术提升了百万人的生活品质","description":"怀揣着英雄梦混迹在江湖中的小人物","author":"GengTao","url":"http://justknow23.github.io","root":"/"},"pages":[{"title":"404","date":"2021-03-20T00:00:00.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"404/index.html","permalink":"http://justknow23.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-28T00:32:31.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"about/index.html","permalink":"http://justknow23.github.io/about/index.html","excerpt":"","text":"关于我：完善中。。。。。"},{"title":"categories","date":"2019-11-28T14:38:58.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"categories/index.html","permalink":"http://justknow23.github.io/categories/index.html","excerpt":"","text":"分类：完善中。。。。。"},{"title":"tags","date":"2021-03-21T14:39:35.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"contact/index.html","permalink":"http://justknow23.github.io/contact/index.html","excerpt":"","text":"留言板：完善中。。。。。"},{"title":"tags","date":"2021-03-21T14:39:35.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"friends/index.html","permalink":"http://justknow23.github.io/friends/index.html","excerpt":"","text":"友情链接：完善中。。。。。"},{"title":"tags","date":"2019-11-28T14:39:35.000Z","updated":"2021-03-22T15:45:12.515Z","comments":true,"path":"tags/index.html","permalink":"http://justknow23.github.io/tags/index.html","excerpt":"","text":"标签：完善中。。。。。"}],"posts":[{"title":"phpstorm-xdebug","slug":"phpstorm-xdebug","date":"2019-11-16T19:47:32.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/11/16/phpstorm-xdebug/","link":"","permalink":"http://justknow23.github.io/2019/11/16/phpstorm-xdebug/","excerpt":"","text":"说明：本文针对已经了解php及其扩展安装的同学，安装扩展过程不再这里赘述。另外本文针对使用docker，php-fpm、nginx-7.3的镜像。手册：https://xdebug.org/ 一、什么是xdebugXdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。在追踪底层源码调用顺序的时候，xdebug是不可或缺的工具。二、xdebug原理1,IDE（如PhpStorm）已经集成了一个遵循BGDP的Xdebug插件，当开启它的时候， 会在本地开一个xdebug调试服务，监听在调试器中所设置的端口上，默认是9000(我这里设置了9001)，这个服务就会监听所有到9000端口的链接。在PhpStorm中，位于：工具栏 &gt; Run &gt; Start / Stop Listening for PHP Xdebug Connetions。2,当浏览器发送一个带XDEBUG_SESSION_START的参数的请求到服务器时，服务器接受后将其转到后端的php处理，如果php开启了xdebug模块，则会将debug信息转发到客户端IP的IDE的调试端口上。当参数或者cookie信息中不带XDEBUG_SESSION_START，则不会启动调试。这就为后续在浏览器中添加开关提供了可能。 3,Xdebug的官方给出了一个示例图：很好的展示了相互调用关系。这个示例图是绑定了ip，即使用了固定ip地址，xdebug.remote_connect_back = 0 ，也是 xdebug 的默认方式，这种情况下，xdebug 在收到调试通知时会读取配置 xdebug.remote_host 和 xdebug.remote_port ，默认是 localhost:9000，然后向这个端口发送通知，这种方式只适合单一客户端开发调试。 三、安装前1.php安装xdebug扩展 xdebug.so2.确认本地环境可安装xdebug版本 https://xdebug.org/wizard3.phpxdebug扩展安装成功如图4.扩展配置 zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20160303/xdebug.so #扩展安装位置 xdebug.remote_enable=1 #开启xdebug xdebug.remote_host=192.168.15.113 #如果是docker镜像 请使用本机ip，其他可使用127.0.0.1 xdebug.remote_port=9001 #告诉php把调试数据上报到哪个监听端口 xdebug.trace_enable_trigger=on xdebug.collect_params=4 xdebug.collect_return=on xdebug.show_mem_delta=on xdebug.trace_output_dir=&quot;/alidata/xdebug/x-trace&quot; xdebug.profiler_output_name = cachegrind.out.%t.%p xdebug.profiler_enable_trigger= on xdebug.profiler_output_dir=&quot;/alidata/xdebug/x-profiler&quot; 四、phpstorm配置","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"Auto狂拽酷炫吊炸天","slug":"auto-zhuai","date":"2019-11-01T23:47:01.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/11/01/auto-zhuai/","link":"","permalink":"http://justknow23.github.io/2019/11/01/auto-zhuai/","excerpt":"","text":"高端大气上档次,低调奢华有内涵， 奔放洋气有深度,简约时尚国际范， 低端粗俗甩节操,土憋矫情无下限， 装模作样绿茶婊,外猛内柔女汉子， 卖萌嘟嘴剪刀手,忧郁深沉无所谓， 狂拽帅气屌炸天,冷艳高贵接地气， 时尚亮丽小清新,可爱乡村非主流， 贵族王朝杀马特,提莫团战必须死。 下载地址：https://xclient.info/s/atom.html插件安装：https://github.com/JoelBesada/activate-power-mode","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"Linux内核","slug":"Linux内核","date":"2019-11-01T23:42:34.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/11/01/linux-nei-he/","link":"","permalink":"http://justknow23.github.io/2019/11/01/linux-nei-he/","excerpt":"","text":"一、内核和进程描述内核由一系列程序组成，包括负责响应中断的中断服务程序、负责管理多个进程从而分享处理器时间的调度程序、负责管理地址空间的内存管理程序、网络、进程间通信的系统服务程序等。 二、Oh My ZshZsh is a shell designed for interactive use, although it is also a powerful scripting language.Many of the useful features of bash, ksh, and tcsh were incorporated into zsh; many original features were added.（Zsh 是为交互使用而设计的一款shell，同时它也是一个强大的脚本语言。很多其他shell的特性, 比如bash、ksh、tcsh, 都被整合到了Zsh中, 并且还添加了很多新的特性） Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with a ton of helpful functions, helpers, plugins, themes, and a few things that make you shout…（Oh My Zsh是一个令人愉快的、开源的、社区驱动的Zsh配置管理框架。它配置了成吨的有用的函数、帮助信息、主题，还有一些令你尖叫的东西。）安装 1.chsh -s /bin/zsh 2.git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 3.cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 4.cd oh-my-zsh/tools &amp;&amp; ./install.sh 5.upgrade_oh_my_zsh 或者 sh -c “$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)”","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"vim 入坑","slug":"vim","date":"2019-11-01T23:38:13.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/11/01/vim/","link":"","permalink":"http://justknow23.github.io/2019/11/01/vim/","excerpt":"","text":"Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性 对于一个重度使用者，就因为喜欢这种双手不离键盘就可以操控一切的feel，Vim 可以让我对文本的操作更加精准、高效。 vim模式正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i进入） 左下角显示–INSERT–可视模式（按v进入） 左下角显示–VISUAL– 打开文件 打开单个文件vim file 同时打开多个文件vim file1 file2.. 在vim窗口中打开一个新文件:open [file] 【举个例子】 当前打开1.txt，做了一些编辑没保存:open! 放弃这些修改，并重新打开未修改的文件 当前打开1.txt，做了一些编辑并保存:open 2.txt 直接退出对1.txt的编辑，直接打开2.txt编辑，省了退出:wq再重新vim 2.txt的步骤 打开远程文件，比如ftp或者share folder:e ftp://192.168.10.76/abc.txt:e \\qadrive\\test\\1.txt 以只读形式打开文件，但是仍然可以使用 :wq! 写入vim -R file 强制性关闭修改功能，无法使用 :wq! 写入vim -M file 插入命令i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 查找命令最简单的查找/text&emsp;&emsp;查找text，按n健查找下一个，按N健查找前一个。?text&emsp;&emsp;查找text，反向查找，按n健查找下一个，按N健查找前一个。vim中有一些特殊字符在查找时需要转义&emsp;&emsp;.*[]^%/?~$ :set ignorecase&emsp;&emsp;忽略大小写的查找:set noignorecase&emsp;&emsp;不忽略大小写的查找复制代码快速查找，不需要手打字符即可查找 向后（下）寻找游标所在处的单词向前（上）寻找游标所在处的单词以上两种查找，n,N 的继续查找命令依然可以适用 5.替换命令~ 反转游标字母大小写r&lt;字母&gt; 将当前字符替换为所写字母R&lt;字母&gt;&lt;字母&gt;… 连续替换字母cc 替换整行（就是删除当前行，并在下一行插入）cw 替换一个单词（就是删除一个单词，就进入插入模式），前提是游标处于单词第一个字母（可用b定位）C (大写C)替换至行尾（和D有所区别，D是删除（剪切）至行尾，C是删除至行位并进入插入模式）:s/old/new/ 用old替换new，替换当前行的第一个匹配:s/old/new/g 用old替换new，替换当前行的所有匹配:%s/old/new/ 用old替换new，替换所有行的第一个匹配:%s/old/new/g 用old替换new，替换整个文件的所有匹配:10,20 s/^/ /g 在第10行至第20行每行前面加四个空格，用于缩进。ddp 交换光标所在行和其下紧邻的一行。 撤销与重做u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。 删除命令需要说明的是，vim 其实并没有单纯的删除命令，下面你或许理解为剪切更加准确。以字符为单位删除x 删除当前字符3x 删除当前字符3次X 删除当前字符的前一个字符。3X 删除当前光标向前三个字符dl 删除当前字符， dl=xdh 删除前一个字符，X=dhD 删除当前字符至行尾。D=d$d$ 删除当前字符至行尾d^ 删除当前字符之前至行首 复制粘贴普通模式中使用y复制yy 复制游标所在的整行（3yy表示复制3行）y^ 复制至行首，或y0。不含光标所在处字符。y$ 复制至行尾。含光标所在处字符。yw 复制一个单词。y2w 复制两个单词。yG 复制至文本末。y1G 复制至文本开头。 区域选择要进行区域选择，要先进入可视模式v 以字符为单位，上下左右选择V 以行为单位，上下选择选择后可进行操作d 剪切/删除y 复制Ctrl+v 如果当前是V(大写)模式，就变成v(小写)如果当前是v(小写)模式，就变成普通模式。如果当前是普通模式，就进入v(小写)模式利用这个，可以进行多行缩进。ggVG 选择全文","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"php常用排序算法","slug":"suanfa","date":"2019-03-01T09:50:15.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/03/01/suanfa/","link":"","permalink":"http://justknow23.github.io/2019/03/01/suanfa/","excerpt":"","text":"php 四种排序算法的时间与内置的sort排序比较 3000个元素，四种算法的排序所用的时间比较 冒泡排序 857.98192024231ms 选择排序 903.74493598938ms 插入排序 296.8270778656ms 快速排序 15.607833862305ms sort排序 0.95200538635254ms 归并排序 14.61386680603ms @param 冒泡排序 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 function BubbleSort($arr) { $len = count($arr); for ($i = 1; $i &lt; $len; $i++) { $flag = false; //本趟排序开始前，交换标志应为假 for ($k = 0; $k &lt; $len - $i; $k++) { //从小到大排序 if ($arr[$k] > $arr[$k + 1]) { $tmp = $arr[$k + 1]; $arr[$k + 1] = $arr[$k]; $arr[$k] = $tmp; $flag = true; } } if(!$flag) return $arr; } } @param 选择排序法 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面） function selectSort($array){ $temp = 0; for($i = 0;$i &lt; count($array) - 1;$i++){ $minVal = $array[$i]; //假设$i就是最小值 $minValIndex = $i; for($j = $i+1;$j &lt; count($array);$j++){ if($minVal > $array[$j]){ //从小到大排列 $minVal = $array[$j]; //找最小值 $minValIndex = $j; } } $temp = $array[$i]; $array[$i] = $array[$minValIndex]; $array[$minValIndex] = $temp; } } 插入排序法 每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。 function insertSort($array){ //从小到大排列 for($i = 1;$i &lt; count($array);$i++){ $insertVal = $array[$i]; //$insertVal是准备插入的数 $insertIndex = $i - 1; //有序表中准备比较的数的下标 while($insertIndex >= 0 &amp;&amp; $insertVal &lt; $array[$insertIndex]){ $array[$insertIndex + 1] = $array[$insertIndex]; //将数组往后挪 $insertIndex--; //将下标往前挪，准备与前一个进行比较 } if($insertIndex + 1 !== $i){ $array[$insertIndex + 1] = $insertVal; } } } ` 快速排序法 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小， 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 function quickSort($array){ if(!isset($array[1])) return $array; $mid = $array[0]; $leftArray = array(); $rightArray = array(); foreach($array as $v){ if($v > $mid) $rightArray[] = $v; if($v &lt; $mid) $leftArray[] = $v; } $leftArray = quickSort($leftArray); $leftArray[] = $mid; $rightArray = quickSort($rightArray); return array_merge($leftArray,$rightArray); } ` 归并排序 归并排序是指将两个或两个以上有序的数列（或有序表），合并成一个仍然有序的数列（或有序表）。 这样的排序方法经常用于多个有序的数据文件归并成一个有序的数据文件。 function mergeSort(&amp;$arr) { $len = count($arr); mSort($arr, 0, $len-1); return $arr; } ` 实际实现归并排序的程序 function mSort(&amp;$arr, $left, $right) { if($left &lt; $right) { $center = floor(($left+$right) / 2); mSort($arr, $left, $center); mSort($arr, $center+1, $right); mergeArray($arr, $left, $center, $right); } } ` 将两个有序数组合并成一个有序数组 function mergeArray(&amp;$arr, $left, $center, $right) { $a_i = $left; $b_i = $center+1; while($a_i&lt;=$center &amp;&amp; $b_i&lt;=$right) { if($arr[$a_i] &lt; $arr[$b_i]) { $temp[] = $arr[$a_i++]; } else { $temp[] = $arr[$b_i++]; } } while($a_i &lt;= $center) { $temp[] = $arr[$a_i++]; } while($b_i &lt;= $right) { $temp[] = $arr[$b_i++]; } for($i=0, $len=count($temp); $i&lt;$len; $i++) { $arr[$left+$i] = $temp[$i]; } }","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"将CSV文件导入表中","slug":"csv2mysql","date":"2019-01-15T21:26:17.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2019/01/15/csv2mysql/","link":"","permalink":"http://justknow23.github.io/2019/01/15/csv2mysql/","excerpt":"","text":"LOAD DATA INFILE 语句可以读取文本文件并导入数据库中。 在导入文件之前，你需要做如下准备： 导入文件的目标数据库csv文件的列与目标数据库表的列的数量相同，并且每列的数据类型相同。有插入数据权限的账户.假设我们有数据表，命名位discounts有如下结构: 用 CREATE TABLE statement 创建discounts 如代码: CREATE TABLE discounts ( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(255) NOT NULL, expired_date DATE NOT NULL, amount DECIMAL(10 , 2 ) NULL, PRIMARY KEY (id) ); 文件discounts.csv文件包含第一行作为列名，其他行作为数据，用以下语句来完成导入功能，例： c:\\tmp\\discounts.csv文件discounts表中； LOAD DATA INFILE ‘c:/tmp/discounts.csv’INTO TABLE discountsFIELDS TERMINATED BY ‘,’ #分隔符ENCLOSED BY ‘“‘ #结尾符LINES TERMINATED BY ‘\\n’ #换行 IGNORE 1 ROWS; #忽略csv文件的第一行文件。csv文件中，每列用逗号来分隔’,’ 用双引号’” ‘作为数据全文的结尾符。.所有的 CSV 文件都是用 ‘\\n’ 换行。.因为文件第一行包含列名，所以，不应该导入数据表中，这里用 IGNORE 1 ROWS option.语句忽略第一行，保证不导入。现在，我们可查看 discounts 表 看数据是否导入。 SELECT * FROM discounts;导入数据过程中变更数据格式：有时候，我们要导入的数据不符合目标数据的格式，简单的解决方式，你可以在导入数据过程中用set语句改变导入数据的格式； expired date 数据是 mm/dd/yyyy 格式如下： 在导入过程中用str_to_date()函数来解决这个问题： LOAD DATA INFILE ‘c:/tmp/discounts_2.csv’INTO TABLE discountsFIELDS TERMINATED BY ‘,’ ENCLOSED BY ‘“‘LINES TERMINATED BY ‘\\n’IGNORE 1 ROWS(title,@expired_date,amount)SET expired_date = STR_TO_DATE(@expired_date, ‘%m/%d/%Y’);远程客户端导入数据在本地电脑导入数据到远端的服务器，同样用LOAD DATA INFILE语句 当加入 LOCAL 参数在 LOAD DATA INFILE语句中 , 客户端会自动读取本地文件，然后将读取的数据发送到服务器端，文件会上传到服务器，临时文件在, C:\\windows\\temp on Windows 或 /tmp on Linux. 此文件不可配置或变更（新版本解除限制） 举例：LOAD DATA LOCAL INFILE ‘c:/tmp/discounts.csv’INTO TABLE discountsFIELDS TERMINATED BY ‘,’ENCLOSED BY ‘“‘LINES TERMINATED BY ‘\\n’IGNORE 1 ROWS;唯一一点不同就是用 LOCAL 参数，如果上传较大的文件，可能会慢一点，毕竟需要将文件上传到服务器需要时间。 通过本地上传文件不需要服务器的特别权限，","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"Git技能持续更新","slug":"git-base","date":"2018-08-02T15:07:34.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2018/08/02/git-base/","link":"","permalink":"http://justknow23.github.io/2018/08/02/git-base/","excerpt":"","text":"一、 基础命令 git branch 查看本地所有分支 git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支 git branch -r 查看远程所有分支 git commit -am “init” 提交并且加注释 git push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout –track origin/dev 切换到远程dev分支 git branch -D master develop 删除本地库develop git checkout -b dev 建立一个新的本地分支dev git merge origin/dev 将分支dev与当前分支进行合并 git checkout dev 切换到本地dev分支 git remote show 查看远程库 git config –list 看所有用户 git ls-files 看已经被提交的 git rm [file name] 删除一个文件 git commit -a 提交当前repos的所有的改变 git add [file name] 添加一个文件到git index git commit -v 当你用－v参数的时候可以看commit的差异 git commit -m “This is the message describing the commit” 添加commit信息 git commit -a -a是代表add，把所有的change加到git index里然后再commit git commit -a -v 一般提交命令 git log 看你commit的日志 git diff 查看尚未暂存的更新 git rm a.a 移除文件(从暂存区和工作区中删除) git rm –cached a.a 移除文件(只从暂存区中删除) git commit -m “remove” 移除文件(从Git中删除) git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除) git diff –cached 或 $ git diff –staged 查看尚未提交的更新 git stash push 将文件给push到一个临时空间中 git stash pop 将文件从临时空间pop下来 二、进阶问题 1.这个分支是谁的？ 2.代码不小新提交到了其他分支上。 3.不小心写错了git commit备注 修改当前提交 、修改历史多个。 4.开发过程中突然接到其中一个功能不做了，但是已经提交了。 一、merge 、rebase 1.normal merge (git merge dev_feature_1) master-&gt;dev merge 不能保持 master 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好 it pull = git fetch + git merge git push –set-upstream origin dev_test_1_191029 1.git config –global user.name “”2.git config –global user.email “”3.git config –list git rm xxx –cached /git rm xxx -fgit mv old.file new.filegit commit –amendgit commit -m”xxx” –date”2019-10-11” git remote -vgit remote set-url origin ssh://xxxxx/php/xx","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"Blog 搭建过程","slug":"contribution-blog","date":"2018-07-30T11:11:30.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2018/07/30/contribution-blog/","link":"","permalink":"http://justknow23.github.io/2018/07/30/contribution-blog/","excerpt":"","text":"玩博客有三个阶段:一、是在平台写，但是写着写着就会发现限制太多。比如博客流量来了，你想挂个广告之类的也不行。二、是自己购买域名和vps自己搭建后台，使用wordpress之类的博客系统，然后自己折腾点赞、评论等功能。但是维护麻烦。比如sql问题，ip问题，就要修复整个系统。三、是使用基于github提供的pages静态网页功能，既可以免费，二来迁移方便。你完全可以把整个系统备份到git上，又保证了写作的自由性，不用维护。本文介绍 Mac上搭建基于github的hexo博客过程。 1.Node.js 进入Node.js官网,一路安装即可。 因为Xcode自带git，所以就没必要下了，如果没有安装的同学可以移步hexo官方文档去下载git 2.安装Hexo当Node.js和git安装好，下面就需要安装Hexo了，终端执行以下命令 sudo npm install -g hexo 3.Hexo 初始化 $ hexo init $ npm install $ hexo s 此时在浏览器中打开网址http://localhost:4000相信就可以看到一个静态网页 4.关联Github创建Github账号并新建项目项目名称为用户名.github.io的固定写法cd 到blog文件夹下,vim打开_config.yml，命令如下 $ vim _config.yml打开后滑倒最后，修改成下面的样子,下面的coding是我在codeing上新建的一个项目，因为在github上访问太慢，所以我新建了一个仓库。deploy: type: git repository: github: https://github.com/justknow23/justknow23.github.io branch: master注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错.注意配置信息里面的行缩进，前面的空格很重要！！！！！！ 修改完成之后保存退出，然后输入以下命令 hexo cleanhexo ghexo d 5.安装主题Hexo官网主题页献给大家大家可以去下载自己喜欢的主题去配置，以下以hexo-theme-next为例终端cd到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： $ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 6.绑定个人域名在/blog/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：gengtt.cn写入. 7.目录结构 _config.yml站点的配置文件，需要拷贝； themes/主题文件夹，需要拷贝； source博客文章的.md文件，需要拷贝； scaffolds/文章的模板，需要拷贝； package.json安装包的名称，需要拷贝； .gitignore限定在push时哪些文件可以忽略，需要拷贝； .git/主题和站点都有，标志这是一个git项目，不需要拷贝； node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝； public是hexo g生成的静态网页，不需要拷贝； .deploy_git同上，hexo g也会生成，不需要拷贝； db.json文件，不需要拷贝。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://justknow23.github.io/tags/技术/"}]},{"title":"作为一名PHPer，永远不要忘了，你是在写PHP的代码","slug":"first-blog","date":"2018-07-27T11:49:32.000Z","updated":"2021-03-22T15:45:12.475Z","comments":true,"path":"2018/07/27/first-blog/","link":"","permalink":"http://justknow23.github.io/2018/07/27/first-blog/","excerpt":"","text":"孔子曾经曰过：源码面前，如同裸奔 任何不考虑具体应用场景的编程模式都是耍流氓 作为一名PHPer，永远不要忘了，你是在写PHP的代码。 生活就是折腾，技术就是倒腾，记录点滴成长进步，保持一颗好奇心。 对程序设计来说，源码是最好的老师，一切概念通描述或者加工后都会存在意义上的偏差，只有通过了解源码才能真正领会其中的含义。","categories":[],"tags":[{"name":"语录","slug":"语录","permalink":"http://justknow23.github.io/tags/语录/"}]}]}